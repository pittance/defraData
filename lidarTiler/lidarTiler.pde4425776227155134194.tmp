
//define indices & data for scan, used to reconstruct file name(s)
String gridSquare = "st";
int xxFrom = 59;
int xxTo = 61;
int yyFrom = 78;
int yyTo = 81;
int numFiles;
String model = "_DSM";
String resoln = "_1M";
String extn = ".asc";

// in a zip file the files store a vertical raster scan down each column
// when sorted alphabetically. The xx number is the left-right index
// The yy number is the up-down index. The filename is constructed from
// the xx and yy numbers in the format:
//   st5076_DSM_1M.asc
// where:
//   st is the grid square
//   50 is xx
//   76 is yy
//   _DSM identifies that this is a digital surface model (includes cars, trees, houses etc.)
//   _1M is the 1m resolution version

LidarRead[] lr;  //need all to get global max/min, read the data and then write image into the output
String[] fileName = new String[0];
String[] fileData;

int[] indexX = new int[0];
int[] indexY = new int[0];
boolean[] ok = new boolean[0];

int numTilesX;
int numTilesY;
int tileRes = 1000;  //1000 points per tile: 1km square @ 1m resolution

float globalMin = 0;
float globalMax = 0;


//  SETTINGS
boolean drawTileNames = false;
// /SETTINGS

PGraphics outputTiles;

void setup() {
  size(100,100);
  smooth();
  
  //find output image data from input settings
  numTilesX = xxTo-xxFrom+1;
  numTilesY = yyTo-yyFrom+1;
  //find resolution of final tiled image and create it
  outputTiles = createGraphics(numTilesX*tileRes,numTilesY*tileRes);
  
  
  
  
  //load filenames into array
  numFiles = 0;
  int countX = 0;
  int countY = 0;
  for (int i=xxFrom;i<=xxTo;i++) {
    countY = 0;
    for (int j=yyTo;j>=yyFrom;j--) {
      numFiles++;
      fileName = expand(fileName,numFiles);
      indexX = expand(indexX,numFiles);
      indexY = expand(indexY,numFiles);
      ok = expand(ok,numFiles);
      fileName[numFiles-1] = gridSquare+i+j+model+resoln+extn;
      indexX[numFiles-1] = countX;
      indexY[numFiles-1] = countY;
      countY++;
    }
    countX++;
  }
  println(fileName);
  println("index files");
  println("        X");
  println(indexX);
  println("        Y");
  println(indexY);
  
  lr = new LidarRead[numFiles];
  
  println("errors");
  
  //load data into the lidarRead data
  boolean minMaxSet = false;
  for (int i=0;i<numFiles;i++) {
    try {
      ok[i] = true;
      println("ok " + i);
      String[] inData = loadStrings(fileName[i]);
      lr[i] = new LidarRead(inData);
    } catch (NullPointerException np) {
      ok[i] = false;
      println("nopenopenopenopenopenopenopenopenopenopenopenopenopenope " + i);
    }
    if (ok[i]) {
      if (!minMaxSet) {
        globalMin = lr[i].minData;
        globalMax = lr[i].maxData;
        println("Initial global min/max: " + globalMin + "/" + globalMax);
        minMaxSet = true;
      }
      if ((globalMax < lr[i].maxData)) {
        print("  reset global max, from:" + globalMax);
        globalMax = lr[i].maxData;
        println(" to: " + globalMax);
      }
      if ((globalMin > lr[i].minData)) {
        print("  reset global min, from:" + globalMin);
        globalMin = lr[i].minData;
        println(" to: " + globalMin);
      }
    }
  }
  
  println("final GLOBAL min: " + globalMin);
  println("final GLOBAL max: " + globalMax);
  
  outputTiles.beginDraw();
  PFont myFont = createFont("arial",30);
  outputTiles.textFont(myFont);
  outputTiles.fill(255,0,0);
  for (int i=0;i<numFiles;i++) {
    println("exporting............." + i);
    if (ok[i]) {
      lr[i].lidarWrite(globalMin,globalMax);
      outputTiles.image(lr[i].imageAlpha,indexX[i]*tileRes,indexY[i]*tileRes);
      if(drawTileNames)outputTiles.text(fileName[i],indexX[i]*tileRes+50,indexY[i]*tileRes+50);
    }
  }
  outputTiles.endDraw(); 
  println("saving.............");
  outputTiles.save("out.png");
  println("done...............");
  
  noLoop();
}

void draw() {
  println("closing...............");
  exit();
}